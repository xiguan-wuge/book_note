## js垃圾收集机制
### 概念： 
 js 具有自动收集垃圾收集机制，即 **执行环境** 会负责管理代码执行过程中的内存。
### 原理：
 找出那些不再使用的变量，然后释放其内存。  
 因此，垃圾收集器会按照固定的时间间隔（或者代码执行中预定的收集时间），周期性地执行这一操作

### 先分析一下函数中局部变量的正常生命周期：
 局部变量 **只在函数执行的过程中存在** 。在这个过程中，js引擎会为局部变量在栈（或堆）内存上分配相应的空间，以便储存他们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放他们的内存以待后面使用，  

### 垃圾收集器执行的方式
 垃圾收集器必须追踪哪个变量有用，哪个变量没用，对于不再使用的变量打上标记，以备 **将来（垃圾收集器下次运行时）** 收回其占用的内存。

### 垃圾收集策略
- ### 标记清除（最常用的垃圾收集方式）  
 当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量打上标记（“进入环境”）。逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就有可能用到它们。而当变量离开环境时，将其标记为“离开环境”。细节如下：  
   垃圾收集器在运行时候会给存储在内存中的所有变量都加上标记（可以使用任何方式）。然后它会 **去掉环境中的变量以及被环境中的变量所引用的变量的标记** 。而在此之后再被加上标记的变量将被视为准备删除的变量（对应上文中：当变量离开环境时，将其标记为”离开环境“），原因是环境中的变量已经无法访问到这些变量了（可以理解为：执行流进入下一个环境）。最后垃圾收集器会完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

- ### 引用计数（不太常见）。
#### 含义：跟踪记录每一个值被引用的次数。
当声明了一个变量（a）并将一个引用类型值(b)赋值给该变量(a)时，则这个值(b)的引用次数就是1，如果同一个值(b)又被赋值给另一个变量(c)，则该值（b）的引用次数加1。相反，如果包含对这个值的引用变量（a）又取得了另一个值（e）,则这个值（b）的引用次数减1.当这个值（b）的引用次数变成0时，则说明没有其他值引用这个值（b）,即没有办法再访问这个变量(b)了，就可以将其占用的内存空间回收。这样，垃圾收集器下次运行时，它就会释放那些引用次数为0的值所占用的内存。
#### 引用计数的问题
循环引用：对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的指针.
```
function problem() {
  var objectA = new Object()
  var objectB = new Object()

  objectA.someOtherObject = objectB
  objectB.anotherObecjt = objectA
}
```
上述例子中，objectA 和objectB的引用次数都是2，循环引用，不会被垃圾回收机制回收。
#### 处理方式： 为避免循环引用，最好是在不使用那些变量时，手动解除引用，（接触一个值的引用并不意味着自动回收该值所占用的内存，解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收）
myObject.element = null;
element.someObject = null
```

### 垃圾收集机制的性能问题
垃圾收集器是周期性运行，确定垃圾收集的时间间隔是非常重要的问题。
IE7中js引擎的修改，触发垃圾收集的变量分配、字面量和数组元素的临界值调整为动态修正。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和数组元素的临界值将会翻倍；如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。

 
 
 
